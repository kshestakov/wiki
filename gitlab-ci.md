## DIY. Настройка Continuous Integration EcoSystem для react-native разработки. Gitlab CI + Fastlane (для автобилда и последующего деплоя) + Crashlytics (для отправки тестировщикам) + IFTTT (для интеграции с Telegram или любым другим сервисом с которым работает https://ifttt.com) + Telegram.

_Цель:_ сделать так, чтобы разработчик написал git push и продолжил писать код дальше как ни в чем не бывало, а тем временем:
1. CI распознала, что появились новые изменения, подтянула проект, установила зависимости, прогнала тесты по новым коммитам, в случае, если тесты свалились - сообщила нам об этом в чате Telegram.
2. Если новые изменения появились в релизной ветке, то после успешного прохождения тестов, с помощью Fastlane, добавила нужных нам тестировщиков в Apple Developer аккаунт (особенно удобно, когда заказчик постепенно приводит все больше и больше тестировщиков, для которых надо каждый раз генерировать новые сертификаты), перевыпустила для них все необходимые сертификаты, проверила наличие необходимых профилей обеспечения (provisioning profiles) в Apple Developer аккаунте, если требуется - сгенерировала новые профили, подписав их нужными нам сертификатами.
3. Далее, присвоила новый номер сборки iOS и android билду, собрала релизные iOS и android билды, подписав их нужными сертификатами. Сгенерировала новые Release Notes для билдов на основе названий коммитов.
4. Разослала iOS и android билды всем указанным тестировщикам, используя crashlytics.
5. Используя сервис IFTTT (https://ifttt.com), отправила сообщение об удачном релизе новой версии приложения в чат Telegram.
6. Если на каком-то этапе произошла ошибка - оповестила об ошибке в чате Telegram.

_Нам потребуются:_ компьютер на macOS, который никогда бы не выключался и, желательно, но не обязательно, источник бесперебойного питания (на всякие непредвиденные ситуации, вроде отключения света).

_Примечание:_ CI включится сразу же, как только мы создадим файл gitlab-ci.yaml. Поэтому, настрйока CI будет описана последним шагом, однако, это дело вкуса, с него можно и начать.

#### Настройка Crashlytics

###### iOS
1. Скачиваем десктопное приложение для мака Fabric
2. Создаем в нем новое приложение на основе сущестующего .xcodeproject или .xcodeworkspace
3. Выбираем в Fabric нужное нам приложение и идем на последнюю вкладку (в нынешней версии Fabric'a (2.6.11 (1282)) она выбрана по умолчанию)
4. Нажимаем на этой вкладке первый пункт "Crashlytics" и приозводим установку соответственно дальнейшим инструкциям в приложении

###### Android
1. Идем сюда: https://fabric.io/kits/android/crashlytics/install
2. Далее есть два пути: либо устанавливаем вручную, по ссылке подробно описано как, либо устанавливаем плагин Fabric для Android Studio, (выглядит точно так же, как и их десктопное приложение) через который устанавливаем Crashlytics по аналогии с iOS.

#### Настройка Fastlane

_Этот раздел инструкций сперва стоит прочитать до конца._

###### iOS
1. У нас два пути: установить Fastlane ручками или через приложение Fabric. Во втором случае мы сразу же получим минимальный конфиг, способный отправлять билды, однако, который потом все равно придется редактировать для полноценной работы. Лично я выбрал второй вариант, но первый ничем не хуже, вот ссылка на установку Fastlane ручками: https://docs.fastlane.tools/getting-started/ios/setup/. fastlane init запускаем из папки, где находится .xcodeproject или .xcodeworkspace (в стандартной иерархии папок это ${PROJECT_NAME}/ios/)
2. Если вы пошли вторым путем, то открываем десктопное приложение Fabric, выбираем нужный нам проект, идем на 3-ю вкладку и тыкаем кнопку Get Fastlane, далее следуем инструкциям 
- _Актуально для обоих путей:_ когда Fastlane попросит ввести AppleID, стоит иметь в виду, что Fastlane сохраняет Apple ID и пароль в связке ключей, поэтому если был введен неправильный, сперва надо его удалить. Найти его можно в связке ключей, выбираем категорию - Пароли и ищем строчку deliver.itech.mobile.dev@gmail.com) 
- _А также:_ поиск по документации Fastlane работает, просто сперва надо секунд 5 подождать, созерцая сообщение "sorry, page not found", а потом уже появятся результаты.
3. Далее нам нужно написать конфиг в ${PROJECT_NAME}/ios/fastlane/Fastfile. Подробно про все возможности можно прочитать в документации к Fastlane, также интересен раздел [Beta-Deployment](https://docs.fastlane.tools/getting-started/ios/beta-deployment/), который содержит различные примеры, поэтапное руководство и Best Practices, я же просто приведу небольшой конфиг с пояснениями как пример.
```ruby
fastlane_version "2.35.1"

default_platform :ios

platform :ios do
# Название команды. В данном случае для запуска в консоли будем писать fastlane beta, 
# в принципе, аналогично npm скриптам.
  lane :beta do |values|
  # Данная команда присваивает новый номер сборки нашему билду, основываясь на переменной
  # окружения GitLab CI build ID, которая увеличивается на единичку с каждым билдом
    increment_build_number(build_number: ENV['CI_BUILD_ID'])
    
    # Следующее действие проверяет, зарегистрированы ли устройства под указанным именем в
    # Apple Developer аккаунте, если нет, то регистрирует UDID (уникальный идентификатор 
    # устройства, посмотреть который можно в iTunes) устройств, на которых будет 
    # производиться тестирование.
    register_devices(
      devices: {
        'Ramil Zayneev' => 'ТУТ_ДОЛЖЕН_БЫЛ_БЫТЬ_РАМИЛЕВСКИЙ_UDID',
        'iphone klushin' => 'ТУТ_ДОЛЖЕН_БЫЛ_БЫТЬ_ЛЕШИН_UDID',
        'ipad_mini_retina_Kirill_Shestakov' => '63da07c67f816b3a7cd8dee47a033a5f2e838443'
      },
      team_id: 'FV8U49NZ7F',
      username: 'itech.mobile.dev@gmail.com'
    )
	# Проверка Distribution сертификатов и их автогенерация при необходимости
    cert(
      username: 'itech.mobile.dev@gmail.com',
      team_id: 'FV8U49NZ7F'
    )
	# Проверка Provisioning Profiles и их автогенерация при необходимости
    # Флаг adhoc нужен, чтобы был сгенерирован профиль для рассылки тестировщикам,
    # а не для загрузки в AppStore
    # Флаг force нужен, чтобы если мы добивли новый девайс для тестировки на шаге 
    # register_devices, нужный нам provisioning profile был перегенерирован с 
    # добавлением в него нового девайса (если девайс не добавить в provisioning profile, 
    # тестировка на нем тестовых билдов будет невозможна)
    sigh(
      adhoc: true,
      force: true,
      app_identifier: 'com.itech.rayfund',
      username: 'itech.mobile.dev@gmail.com',
      team_id: 'FV8U49NZ7F'
    )

    # Устанавливаем export_method: 'ad-hoc' для распространения тестовых билдов. В таком 
    # случае будет использоваться AdHoc provisioning profile, если, например, хотим 
    # залить приложение в AppStore, то там будет стоять 'app-store'
    gym(scheme: 'rayfund', export_method: 'ad-hoc')

	# После двоеточия перечислены имейлы, на которые придут ссылки, чтобы скачать тестовый 
    # билд
    emails = values[:test_email] ? values[:test_email] : ['ТУТ_ДОЛЖЕН_БЫЛ_БЫТЬ_РАМИЛЕВСКИЙ_ИМЕЙЛ', 'ТУТ_ДОЛЖЕН_БЫЛ_БЫТЬ_ЛЕШИН_ИМЕЙЛ', 'nymizmat73@gmail.com'] 
    groups = values[:test_email] ? nil : nil 
    
    # Сообщение, представляющее собой release notes на основе названия последнего коммита, 
    # которое придет в письме тестировщикам вместе с сылкой на тестовый билд
    message = last_git_commit[:message]
    
	# Отправка тестового билда через crashlytics
    crashlytics(api_token: 'ТУТ_ДОЛЖЕН_БЫЛ_БЫТЬ_АПИ_ТОКЕН_КРАШЛИТИКСА',
             build_secret: 'ТУТ_ДОЛЖНА_БЫЛА_БЫТЬ_ДЛИННАЯ_ПОСЛЕДОВАТЕЛЬНОСТЬ_БУКВ_И_ЦИФР',
                   emails: emails,
                   groups: groups,
                    notes: message, 
            notifications: true) 
    # Отправка уведомления об успешном деплое приложения в Telegram через IFTTT
    # Fastlane сам сделает нужный POST-запрос, чтобы триггернуть ивент app_deployed
    # Пример запроса:
    # https://maker.ifttt.com/trigger/app_deployed/with/key/cud_xuV8X9PRk1rR6a5O1_
    # Узнать свой api_key можно тут: 
    # https://ifttt.com/services/maker_webhooks/settings
    # Ищем поле URL и все символы после последнего слеша в урле и есть наш api_key
    ifttt(
      api_key: "cud_xuV8X9PRk1rR6a5O1_",
      event_name: "app_deployed"
    )
  end
end

```

###### Android
1. Можно просто ткнуть Setup в разделе Android в документации Fastlane, или вот прямая ссылка на инструкцию по установке Fastlane для Android проекта: https://docs.fastlane.tools/getting-started/android/setup/. fastlane init запускаем из папки: ${PROJECT_NAME}/android/ по аналогии с iOS проектом
2. Аналогично с iOS нужно написать конфиг в ${PROJECT_NAME}/android/fastlane/Fastfile. Пример с комментариями ниже.
```ruby
fastlane_version "2.35.1"

default_platform :android
# Название команды, аналогично iOS конфигу
lane :beta do |values|
# Собираем релизный билд
  gradle(
    task: 'assemble',
    build_type: 'Release'
  )
# Указываем имейлы тестировщиков
  emails = values[:test_email] ? values[:test_email] : ['felixpro@list.ru', 'bacrilio@gmail.com', 'k.schepetkov@yandex.ru'] 
  # Сообщение для release notes на основе названия последнего коммита
  message = last_git_commit[:message]
  # Отправка билда через Crashlytics
  crashlytics(
    api_token: "ТУТ_ДОЛЖЕН_БЫЛ_БЫТЬ_АПИ_ТОКЕН_КРАШЛИТИКСА",
    build_secret: "ТУТ_ДОЛЖНА_БЫЛА_БЫТЬ_ДЛИННАЯ_ПОСЛЕДОВАТЕЛЬНОСТЬ_БУКВ_И_ЦИФР",
    emails: emails,
    notes: message, 
    notifications: true
  )
end
```

#### Настройка Telegram

1. Ищем IFTTT бота по нику @IFTTT и добавляем его в друзья
2. В диалоге с ним пишем /start (если придется регистрироваться на ifttt.com - регистрируемся)
3. Далее пишем либо /connect_group либо /connect_channel в зависимости от потребностей (предлагаю сделать сперва одно, потом второе и сразу же станет ясно, что именно требуетя) и выбираем чат, в котором мы хотим получать уведомления от IFTTT бота
4. После того, как мы написали /connect_group, появится кнопка Choose a Group, однако, на десктопе она не работает, но зато прекрасно работает в мобильном приложении.
5. IFTTT бота надо добавить в чат, в котором он будет писать сообщения

#### Настройка IFTTT

_Как это работает:_ мы делаем POST запрос к сервису Web hooks, предоставляемый IFTTT, после чего триггерится определенное событие и телеграмовский IFTTT бот пишет в нужном нам чате нужное нам сообщение. 
Пример запроса: https://maker.ifttt.com/trigger/app_deployed/with/key/cud_xuV8X9PRk1rR6a5O1_

1. Регистрируемся на https://ifttt.com, если еще не зарегистрировались, после чего у нас есть два пути (2ой дает возможность интегрировать кастомную логику обработки ивента с помощью js):

###### Быстро и с базовым функционалом:
1. Идем в My Applets
2. Нажимаем New Applet
3. Тыкаем по большому синему слову this
4. С помощью поиска выбираем Maker webhooks
5. Жмем на карточку Receive a web request
6. Вписываем название события, после которого по нашей задумке должно произойти оповещение в Telegram, например, app_deployed
7. Тыкаем по большому синему слову that
8. С помощью поиска выбираем Telegram
9. Жмем на нужную нам карточку, в моем случае это была Send message
10. Выбираем чат, в котором IFTTT бот будет писать уведомления
11. Далее вписываем текст сообщения, которое мы получим после того, как событие произойдет (в тексте собщения нам доступны некоторые параметры, такие как {{EventName}}, {{OccurredAt}}, {{Value1}}, {{Value2}}, {{Value3}}, параметры Value\* можно передавать в POST-запросе)
12. В последнем дропдаун листе выбираем, хотим ли мы, чтобы IFTTT бот делал превьюшку первой найденной ссылки в тексте сообщения или нет
13. Тыкаем Create action
14. Тыкаем Finish
15. На следующей странице мы можем включить или выключить данный апплет, а также проверить, работает он или нет с помощью кнопочки Check now (в случае успеха телеграмовский IFTTT бот пришлет сообщение)

###### Медленнее, но с тонкой настройкой:
1. Идем на сайт https://ifttt.com и скроллим в самый низ
2. Ищем там надпись Platform и жмем на нее
3. Далее жмем New Applet
4. С помощью поиска выбираем Maker webhooks
5. С помощью дропдаун листа выбираем Receive a web request
6. Field Label оставляем нетронутым (тут можно менять название поля, но на работу апплета это никак не влияет)
7. Настраиваем видимость нашего апплета для других пользователей платформой IFTTT
8. В поле default_value вписываем название события, после которого по нашей задумке должно произойти оповещение в Telegram, например, app_deployed
9. Нажимаем Add action
10. С помощью поиска выбираем Telegram
11. С помощью дропдаун листа выбираем нужное действие, в моем случае это был Send message
12. Field Label менять не обязательно
13. Настраиваем видимость, доходим до поля Value, куда вписываем текст сообщения, которое мы получим после того, как событие произойдет (в тексте собщения нам доступны некоторые параметры с помощью кнопки Add ingridient, такие как {{EventName}}, {{OccurredAt}}, {{Value1}}, {{Value2}}, {{Value3}}, параметры Value\* можно передавать в POST-запросе)
14. Далее встречаем еще одни настройки видимости и дропдаун лист, определяющий, будет ли IFTTT бот делать превьюшку первой найденной ссылки в тексте сообщения или нет
15. Промотав чуть вниз, видим кнопку Add action, благодаря которой мы имеем возможность добавить еще одну реакцию (action) на все тот же ивент
16. Теперь если промотать немного вверх, мы увидим, что разблокировалась кнопка Add filter code, которая нам дает возможность интегрировать кастомную логику обработки ивента. То есть там можно написать свой js код, который отработает после того, как ивент произойдет, но до того, как произойдет реакция на него, плюс, там есть доступ к некоторым полям и методам, относящихся к ивенту. Нажав на кнопку, можно увидеть ссылку на соответсвующий раздел документации с примерами.
17. В самом низу настраивается заголовок апплета, описание и иконка, все это определяет его отображение в разделе Applets
18. После того, как настроили все, что хотели, нажимаем Save

#### Настройка Gitlab CI

_Примечание:_ надо быть админом репозитория проекта, к которому прикручиваем CI

1. Сперва создаем раннер. На какой машине его создадим - та и будет билдить, гонять тесты, отправлять билды, в общем, заниматься всей той работой, которую мы хотим автоматизировать. Идем сюда: https://docs.gitlab.com/runner/install/osx.html и выполняем первые два маркированных пункта
2. Дойдя до маркированного пункта Register the Runner, идем на гитлаб в репозиторий нашего проекта, выбираем вкладку Settings, затем CI/CD Pipelines, в разделе Specific Runners запоминаем урлу и наш registration token из пунктов 2 и 3 соответственно
3. Скроллим вниз до раздела CI/CD Pipelines, вставляем наш registration token в поле Runner token (если вдруг не сработает, то скроллим вверх до нашего раннера, нажимаем кнопку редактирования и копируем поле token и используем его) и настраиваем наш пайплайн как нам нужно (будет ли компьютер каждый раз клонировать репозиторий или нет, приватность, таймаут и пр.), нажимаем Save changes
4. Регистрируем наш раннер по этой инструкции: https://docs.gitlab.com/runner/register/index.html#macos 
- На 1-ом шаге, возможно, придется использовать команду sudo gitlab-ci-multi-runner register
- На шагах 2 и 3 используем запомненные урлу и registration token
- Если затрудняетесь, что выбрать в 8 шаге - выбираем shell
5. Снова идем сюда: https://docs.gitlab.com/runner/install/osx.html и выполняем инструкции после маркированного пункта Register the Runner (потребуется перезагрузка компьютера)
6. Создаем gitlab-ci.yaml в корневой папке react-native проекта. Тут есть хорошая документация, описывающая разные параметры в конфиге: https://docs.gitlab.com/ee/ci/yaml/README.html я же просто приведу небольшой конфиг с пояснениями как пример.
```ruby
# Перед каждым стейджем будет склонирован git clone репозитория и применены команды из списка before_script
before_script:
  - npm i
  - cd ios
  - pod install
  - pod update
  - cd ..
  - cp -a ~/Downloads/vk-ios-sdk/ ios/vk-ios-sdk
  - sed -i '' 's/facebook-android-sdk:4.+/facebook-android-sdk:4.22.0/g' node_modules/react-native-fbsdk/android/build.gradle
  - sed -i '' 's/#import "VKSdk.h"/#import <VKSdkFramework\/VKSdkFramework.h>/g' node_modules/react-native-vkontakte-login/ios/*
  - sed -i '' 's/23\.1\.0/25.0.0/g; s/23\.0\.1/25.0.0/g; s/23/25/g' node_modules/react-native-fbsdk/android/build.gradle
  - sed -i '' 's/23\.0\.1/25.0.0/g' node_modules/react-native-fetch-blob/android/build.gradle
  - sed -i '' 's/23\.0\.1/25.0.0/g' node_modules/react-native-linear-gradient/android/build.gradle
  - sed -i '' 's/23\.0\.1/25.0.0/g' node_modules/react-native-vkontakte-login/android/build.gradle
# Перечисление всех стейджей
stages:
  - test
  - test_failure
  - deploy
  - deploy_failure
# название джоба (в одном стейдже может быть несколько джобов, они будут запускаться параллельно)
test_job:
# какому стейджу принадлежит данный джоб
  stage: test
  # какую команду выполнит данный джоб
  script:
    - npm run test

test_failure_job:
  stage: test_failure
  script:
  # таким образом триггерим сообщение об ошибке в Telegram
    - curl -X POST https://maker.ifttt.com/trigger/test_failure/with/key/cud_xuV8X9PRk1rR6a5O1_
  # данный джоб выполнится, только если один из предыдущих джобов сфейлился
  when: on_failure

deploy_job:
  stage: deploy
  script:
    - cd android
    - fastlane beta
    - cd ../ios
    - fastlane beta
  # данный джоб будет выполнен только если увидит новые изменения в ветке develop
  only:
    - develop

deploy_failure_job:
  stage: deploy_failure
  script:
    - curl -X POST https://maker.ifttt.com/trigger/deploy_failure/with/key/cud_xuV8X9PRk1rR6a5O1_
  when: on_failure
  only:
    - develop

```